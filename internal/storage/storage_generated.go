// Code generated by fabrica generate. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage convenience functions for your resources.
// It uses the fabrica storage backend system.
//
// To modify storage behavior:
//  1. Edit pkg/codegen/templates/storage.go.tmpl
//  2. Run 'fabrica generate' to regenerate
//
// To change storage backend:
//  1. Call storage.Init() with a different backend in main.go
//  2. Options: FileBackend, EntBackend (database), or custom backend
package storage

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/openchami/fabrica/pkg/reconcile"
	fabricaStorage "github.com/openchami/fabrica/pkg/storage"

	"github.com/rainest/fab-test/apis/pcs.example/v1"
)

// Backend is the storage backend used by all storage operations.
// Initialize this in your main.go before using any storage functions.
//
// Example:
//
//	backend, err := fabricaStorage.NewFileBackend("./data")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	storage.Init(backend)
var Backend fabricaStorage.StorageBackend

// Init initializes the storage backend.
// This must be called before using any storage functions.
func Init(backend fabricaStorage.StorageBackend) {
	Backend = backend
}

// InitFileBackend is a convenience function to initialize file-based storage.
// It creates the directory if it doesn't exist.
func InitFileBackend(dataDir string) error {
	backend, err := fabricaStorage.NewFileBackend(dataDir)
	if err != nil {
		return fmt.Errorf("failed to create file backend: %w", err)
	}
	Backend = backend
	return nil
}

// ensureBackend panics if Backend is not initialized.
// This is called by all storage functions to ensure proper initialization.
func ensureBackend() {
	if Backend == nil {
		panic("storage backend not initialized: call storage.Init() or storage.InitFileBackend() in main.go")
	}
}

// PowerStatusComponent storage operations

// LoadAllPowerStatusComponents retrieves all PowerStatusComponent resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []*v1.PowerStatusComponent: Slice of PowerStatusComponent resources
//   - error: Any error that occurred during loading
func LoadAllPowerStatusComponents(ctx context.Context) ([]*v1.PowerStatusComponent, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "PowerStatusComponent")
	if err != nil {
		return nil, fmt.Errorf("failed to load all powerstatuscomponents: %w", err)
	}

	powerstatuscomponents := make([]*v1.PowerStatusComponent, 0, len(rawData))
	for _, raw := range rawData {
		powerStatusComponent := &v1.PowerStatusComponent{}
		if err := json.Unmarshal(raw, powerStatusComponent); err != nil {
			return nil, fmt.Errorf("failed to unmarshal PowerStatusComponent: %w", err)
		}
		powerstatuscomponents = append(powerstatuscomponents, powerStatusComponent)
	}

	return powerstatuscomponents, nil
}

// LoadPowerStatusComponent retrieves a single PowerStatusComponent resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the PowerStatusComponent resource
//
// Returns:
//   - *v1.PowerStatusComponent: The PowerStatusComponent resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func LoadPowerStatusComponent(ctx context.Context, uid string) (*v1.PowerStatusComponent, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "PowerStatusComponent", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load PowerStatusComponent %s: %w", uid, err)
	}

	powerStatusComponent := &v1.PowerStatusComponent{}
	if err := json.Unmarshal(rawData, powerStatusComponent); err != nil {
		return nil, fmt.Errorf("failed to unmarshal PowerStatusComponent: %w", err)
	}

	return powerStatusComponent, nil
}

// SavePowerStatusComponent stores a PowerStatusComponent resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - powerStatusComponent: The PowerStatusComponent resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func SavePowerStatusComponent(ctx context.Context, powerStatusComponent *v1.PowerStatusComponent) error {
	ensureBackend()

	data, err := json.Marshal(powerStatusComponent)
	if err != nil {
		return fmt.Errorf("failed to marshal PowerStatusComponent: %w", err)
	}

	if err := Backend.Save(ctx, "PowerStatusComponent", powerStatusComponent.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save PowerStatusComponent: %w", err)
	}

	return nil
}

// UpdatePowerStatusComponent updates an existing PowerStatusComponent resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - powerStatusComponent: The PowerStatusComponent resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func UpdatePowerStatusComponent(ctx context.Context, powerStatusComponent *v1.PowerStatusComponent) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "PowerStatusComponent", powerStatusComponent.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check PowerStatusComponent existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal(powerStatusComponent)
	if err != nil {
		return fmt.Errorf("failed to marshal PowerStatusComponent: %w", err)
	}

	if err := Backend.Save(ctx, "PowerStatusComponent", powerStatusComponent.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update PowerStatusComponent: %w", err)
	}

	return nil
}

// DeletePowerStatusComponent removes a PowerStatusComponent resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the PowerStatusComponent resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func DeletePowerStatusComponent(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "PowerStatusComponent", uid); err != nil {
		return fmt.Errorf("failed to delete PowerStatusComponent %s: %w", uid, err)
	}

	return nil
}

// ExistsPowerStatusComponent checks if a PowerStatusComponent resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the PowerStatusComponent resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func ExistsPowerStatusComponent(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "PowerStatusComponent", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check PowerStatusComponent existence: %w", err)
	}

	return exists, nil
}

// ListPowerStatusComponentUIDs returns UIDs of all PowerStatusComponent resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of PowerStatusComponent resource UIDs
//   - error: Any error that occurred during listing
func ListPowerStatusComponentUIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "PowerStatusComponent")
	if err != nil {
		return nil, fmt.Errorf("failed to list PowerStatusComponent UIDs: %w", err)
	}

	return uids, nil
}

// Transition storage operations

// LoadAllTransitions retrieves all Transition resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []*v1.Transition: Slice of Transition resources
//   - error: Any error that occurred during loading
func LoadAllTransitions(ctx context.Context) ([]*v1.Transition, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "Transition")
	if err != nil {
		return nil, fmt.Errorf("failed to load all transitions: %w", err)
	}

	transitions := make([]*v1.Transition, 0, len(rawData))
	for _, raw := range rawData {
		transition := &v1.Transition{}
		if err := json.Unmarshal(raw, transition); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Transition: %w", err)
		}
		transitions = append(transitions, transition)
	}

	return transitions, nil
}

// LoadTransition retrieves a single Transition resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Transition resource
//
// Returns:
//   - *v1.Transition: The Transition resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func LoadTransition(ctx context.Context, uid string) (*v1.Transition, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "Transition", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load Transition %s: %w", uid, err)
	}

	transition := &v1.Transition{}
	if err := json.Unmarshal(rawData, transition); err != nil {
		return nil, fmt.Errorf("failed to unmarshal Transition: %w", err)
	}

	return transition, nil
}

// SaveTransition stores a Transition resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - transition: The Transition resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func SaveTransition(ctx context.Context, transition *v1.Transition) error {
	ensureBackend()

	data, err := json.Marshal(transition)
	if err != nil {
		return fmt.Errorf("failed to marshal Transition: %w", err)
	}

	if err := Backend.Save(ctx, "Transition", transition.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save Transition: %w", err)
	}

	return nil
}

// UpdateTransition updates an existing Transition resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - transition: The Transition resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func UpdateTransition(ctx context.Context, transition *v1.Transition) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "Transition", transition.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check Transition existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal(transition)
	if err != nil {
		return fmt.Errorf("failed to marshal Transition: %w", err)
	}

	if err := Backend.Save(ctx, "Transition", transition.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update Transition: %w", err)
	}

	return nil
}

// DeleteTransition removes a Transition resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Transition resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func DeleteTransition(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "Transition", uid); err != nil {
		return fmt.Errorf("failed to delete Transition %s: %w", uid, err)
	}

	return nil
}

// ExistsTransition checks if a Transition resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Transition resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func ExistsTransition(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "Transition", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check Transition existence: %w", err)
	}

	return exists, nil
}

// ListTransitionUIDs returns UIDs of all Transition resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of Transition resource UIDs
//   - error: Any error that occurred during listing
func ListTransitionUIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "Transition")
	if err != nil {
		return nil, fmt.Errorf("failed to list Transition UIDs: %w", err)
	}

	return uids, nil
}

// StorageClient wraps a StorageBackend to implement reconcile.ClientInterface.
//
// This adapter allows reconcilers to use the storage backend through a
// standard interface that provides typed resource access.
type StorageClient struct {
	backend fabricaStorage.StorageBackend
}

// Compile-time check that StorageClient implements reconcile.ClientInterface
var _ reconcile.ClientInterface = (*StorageClient)(nil)

// NewStorageClient creates a new storage client that wraps the configured backend.
//
// This is used by the reconciliation system to provide reconcilers with
// access to resource storage.
//
// Returns:
//   - *StorageClient: Client that implements reconcile.ClientInterface
func NewStorageClient() *StorageClient {
	ensureBackend()
	return &StorageClient{backend: Backend}
}

// --- Version snapshot helpers (file backend only) ---

// Get retrieves a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//   - uid: Unique identifier
//
// Returns:
//   - interface{}: The resource (type-specific)
//   - error: Any error that occurred
func (c *StorageClient) Get(ctx context.Context, kind, uid string) (interface{}, error) {
	rawData, err := c.backend.Load(ctx, kind, uid)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "PowerStatusComponent":
		var resource v1.PowerStatusComponent
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal PowerStatusComponent: %w", err)
		}
		return &resource, nil
	case "Transition":
		var resource v1.Transition
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Transition: %w", err)
		}
		return &resource, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// List retrieves all resources of a given kind.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//
// Returns:
//   - []interface{}: Slice of resources
//   - error: Any error that occurred
func (c *StorageClient) List(ctx context.Context, kind string) ([]interface{}, error) {
	rawData, err := c.backend.LoadAll(ctx, kind)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "PowerStatusComponent":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource v1.PowerStatusComponent
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal PowerStatusComponent: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	case "Transition":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource v1.Transition
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal Transition: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// Update updates an existing resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to update
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Update(ctx context.Context, resource interface{}) error {
	data, err := json.Marshal(resource)
	if err != nil {
		return fmt.Errorf("failed to marshal resource: %w", err)
	}

	// Extract kind and UID based on type
	switch res := resource.(type) {
	case *v1.PowerStatusComponent:
		return c.backend.Save(ctx, "PowerStatusComponent", res.Metadata.UID, data)
	case *v1.Transition:
		return c.backend.Save(ctx, "Transition", res.Metadata.UID, data)
	default:
		return fmt.Errorf("unknown resource type: %T", resource)
	}
}

// Create creates a new resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to create
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Create(ctx context.Context, resource interface{}) error {
	// For storage backend, Create is the same as Update (Save handles both)
	return c.Update(ctx, resource)
}

// Delete deletes a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind
//   - uid: Unique identifier
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Delete(ctx context.Context, kind, uid string) error {
	return c.backend.Delete(ctx, kind, uid)
}
